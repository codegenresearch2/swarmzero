import pytest\nimport fastapi\nimport status\nfrom unittest.mock import AsyncMock, MagicMock, patch\nfrom fastapi import APIRouter, FastAPI\nfrom llama_index.core.llms import ChatMessage, MessageRole\nfrom swarmzero.sdk_context import SDKContext\nfrom swarmzero.server.routes.chat import setup_chat_routes\n\n\nclass MockAgent:\n    async def astream_chat(self, content, chat_history):\n        async def async_response_gen():\n            yield "chat response"\n        return type("MockResponse", (), {"async_response_gen": async_response_gen})\n\n    async def achat(self, content, chat_history):\n        return "chat response"\n\nclass MockMultiModalAgent:\n    def create_task(self, content, extra_state=None):\n        return type("MockTask", (), {"task_id": "12345"})\n\n    async def _arun_step(self, task_id):\n        return type("MockResponse", (), {"is_last": True})\n\n    def finalize_response(self, task_id):\n        return "multimodal response"\n\nclass MockDatabaseManager:\n    def __init__(self):\n        self.data = []\n\n    async def insert_data(self, table_name: str, data: dict):\n        self.data.append(data)\n\n    async def read_data(self, table_name: str, filters: dict):\n        return [d for d in self.data if all(d[k] == v[0] for k, v in filters.items())]\n\n@pytest.fixture\ndef agent():\n    return MockAgent()\n\n@pytest.fixture\ndef multi_modal_agent():\n    agent = MockMultiModalAgent()\n    agent._arun_step = AsyncMock(side_effect=agent._arun_step)\n    agent.finalize_response = MagicMock(side_effect=agent.finalize_response)\n    return agent\n\n@pytest.fixture\ndef db_manager():\n    return MockDatabaseManager()\n\n@pytest.fixture\ndef sdk_context():\n    mock_context = MagicMock(spec=SDKContext)\n    mock_context.get_attributes.return_value = {\n        'llm': MagicMock(),\n        'agent_class': lambda *args: MagicMock(agent=MockAgent()),\n        'tools': [],\n        'instruction': "",\n        'tool_retriever': None,\n        'enable_multi_modal': False,\n    }\n    return mock_context\n\n@pytest.fixture\ndef app(agent, sdk_context):\n    fastapi_app = FastAPI()\n    v1_router = APIRouter()\n    setup_chat_routes(v1_router, "test_id", sdk_context)\n    fastapi_app.include_router(v1_router, prefix="/api/v1")\n    return fastapi_app\n\n@pytest.fixture\nasync def client(app):\n    async with fastapi.testclient.AsyncClient(app=app, base_url="http://test") as test_client:\n        yield test_client\n\n@pytest.mark.asyncio\nasync def test_chat_no_messages(client):\n    form_data = {\n        "user_id": "user1",\n        "session_id": "session1",\n        "chat_data": json.dumps({"messages": []}),\n    }\n    response = await client.post("/api/v1/chat", data=form_data, files={})\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert "No messages provided" in response.json()["detail"]\n\n@pytest.mark.asyncio\nasync def test_chat_last_message_not_user(client):\n    form_data = {\n        "user_id": "user1",\n        "session_id": "session1",\n        "chat_data": json.dumps(\n            {\n                "messages": [\n                    {"role": MessageRole.SYSTEM, "content": "System message"},\n                    {"role": MessageRole.USER, "content": "User message"},\n                    {"role": MessageRole.SYSTEM, "content": "Another system message"}\n                ]\n            }\n        ),\n    }\n    response = await client.post("/api/v1/chat", data=form_data, files={})\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert "Last message must be from user" in response.json()["detail"]\n\n@pytest.mark.asyncio\nasync def test_chat_malformed_chat_data(client):\n    payload = {"user_id": "user1", "session_id": "session1", "chat_data": "invalid_json"}\n    files = [("files", ("test.txt", BytesIO(b"test content"), "text/plain"))]\n    response = await client.post("/api/v1/chat", data=payload, files={**dict(files)})\n    assert response.status_code == status.HTTP_400_BAD_REQUEST\n    assert "Chat data is malformed" in response.json()["detail"]\n\n@pytest.mark.asyncio\nasync def test_chat_success(client, agent):\n    with (\n        patch("swarmzero.server.routes.chat.ChatManager.generate_response", return_value="chat response"),\n        patch('swarmzero.server.routes.chat.insert_files_to_index', return_value=['test.txt']),\n        patch("swarmzero.server.routes.chat.inject_additional_attributes", new=lambda fn, attributes=None: fn()),\n    ):\n        payload = {\n            "user_id": "user1",\n            "session_id": "session1",\n            "chat_data": json.dumps({"messages":[{"role": "user", "content": "Hello!"}]}),\n        }\n        files = [("files", ("test.txt", BytesIO(b"test content"), "text/plain"))]\n        response = await client.post("/api/v1/chat", data=payload, files={**dict(files)})\n        assert response.status_code == status.HTTP_200_OK\n        assert response.text == "chat response" or response.text == '"chat response"'\n\n@pytest.mark.asyncio\nasync def test_chat_with_image(client, agent):\n    with (\n        patch(\n            "swarmzero.server.routes.chat.ChatManager.generate_response", return_value="chat response"\n        ) as mock_generate_response,\n        patch('swarmzero.server.routes.chat.insert_files_to_index', return_value=['test.txt', 'test.jpg']),\n        patch("swarmzero.server.routes.chat.inject_additional_attributes", new=lambda fn, attributes=None: fn()),\n    ):\n        payload = {\n            "user_id": "user1",\n            "session_id": "session1",\n            "chat_data": json.dumps({"messages":[{"role": "user", "content": "Hello!"}]}),\n        }\n        files = [("files", ("test.txt", BytesIO(b"test content"), "text/plain")),("files", ("test.jpg", BytesIO(b"test content"), "image/jpg"))]\n        response = await client.post("/api/v1/chat", data=payload, files={**dict(files)})\n        assert response.status_code == status.HTTP_200_OK\n        assert response.text == "chat response" or response.text == '"chat response"'\n        mock_generate_response.assert_called_once_with(ANY, ANY, ['test.jpg'])\n\n@pytest.mark.asyncio\nasync def test_get_chat_history_success(client):\n    user_id = "user1"\n    session_id = "session1"\n    expected_chat_history = [\n        {"role": MessageRole.USER, "content": "Hello!"},\n        {"role": MessageRole.ASSISTANT, "content": "Hi there!"}\n    ]\n    mock_chat_manager = AsyncMock()\n    mock_chat_manager.get_messages.return_value = [\n        ChatMessage(role=msg["role"], content=msg["content"]) for msg in expected_chat_history\n    ]\n    with patch("swarmzero.server.routes.chat.ChatManager", return_value=mock_chat_manager):\n        response = await client.get(f"/api/v1/chat_history?user_id={user_id}&session_id={session_id}")\n        assert response.status_code == status.HTTP_200_OK\n        response_data = response.json()\n        assert len(response_data) == len(expected_chat_history)\n        for expected_msg, actual_msg in zip(expected_chat_history, response_data):\n            assert actual_msg["role"] == expected_msg["role"]\n            assert actual_msg["message"] == expected_msg["content"]\n\n@pytest.mark.asyncio\nasync def test_get_all_chats_success(client):\n    user_id = "user1"\n    expected_all_chats = {\n        "session1": [\n            {"message": "Hello in session1", "role": "USER", "timestamp": "timestamp1"},\n            {"message": "Response in session1", "role": "ASSISTANT", "timestamp": "timestamp2"}\n        ],\n        "session2": [\n            {"message": "Hello in session2", "role": "USER", "timestamp": "timestamp3"},\n            {"message": "Response in session2", "role": "ASSISTANT", "timestamp": "timestamp4"}\n        ],\n    }\n    mock_chat_manager = AsyncMock()\n    mock_chat_manager.get_all_chats_for_user.return_value = expected_all_chats\n    with patch("swarmzero.server.routes.chat.ChatManager", return_value=mock_chat_manager):\n        response = await client.get(f"/api/v1/all_chats?user_id={user_id}")\n        assert response.status_code == status.HTTP_200_OK\n        response_data = response.json()\n        assert response_data == expected_all_chats\n